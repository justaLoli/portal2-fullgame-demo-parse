/**
 * MIT License
 *
 * Copyright (c) 2020, bit-buffer developers
 * Copyright (c) 2023-2024, NeKz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 * Modified version of: https://github.com/inolen/bit-buffer
 *
 * Changes:
 *      - Converted to TypeScript
 *      - Replaced prototype definitions with class properties, methods, getters
 *        and setters
 *      - Replaced `var` with `const`/`let`
 *      - Removed multiple assignment expressions
 *      - Replaced `function` definitions with ES6 arrow functions
 *      - Inlined a bunch of module scoped functions
 *      - Removed references to NodeJs Buffer
 */
/**
 * BitView
 *
 * BitView provides a similar interface to the standard
 * DataView, but with support for bit-level reads / writes.
 */
export declare class BitView {
    constructor(source: ArrayBuffer, byteOffset?: number, byteLength?: number);
    _view: Uint8Array;
    bigEndian: boolean;
    _scratch: DataView;
    get buffer(): ArrayBufferLike;
    get byteLength(): number;
    _setBit(offset: number, on: boolean): void;
    getBits(offset: number, bits: number, signed?: boolean): number;
    setBits(offset: number, value: number, bits: number): void;
    getBoolean(offset: number): boolean;
    getInt8(offset: number): number;
    getUint8(offset: number): number;
    getInt16(offset: number): number;
    getUint16(offset: number): number;
    getInt32(offset: number): number;
    getUint32(offset: number): number;
    getFloat32(offset: number): number;
    getFloat64(offset: number): number;
    setBoolean(offset: number, value: boolean): void;
    setInt8(offset: number, value: number): void;
    setUint8(offset: number, value: number): void;
    setInt16(offset: number, value: number): void;
    setUint16(offset: number, value: number): void;
    setInt32(offset: number, value: number): void;
    setUint32(offset: number, value: number): void;
    setFloat32(offset: number, value: number): void;
    setFloat64(offset: number, value: number): void;
    getArrayBuffer(offset: number, byteLength: number): Uint8Array;
}
/**
 * BitStream
 *
 * Small wrapper for a BitView to maintain your position,
 * as well as to handle reading / writing of string data
 * to the underlying buffer.
 */
export declare class BitStream {
    constructor(source: ArrayBuffer | BitView, byteOffset?: number, byteLength?: number);
    protected _view: BitView;
    protected _index: number;
    protected _startIndex: number;
    protected _length: number;
    get offset(): number;
    get index(): number;
    set index(val: number);
    get length(): number;
    set length(val: number);
    get bitsLeft(): number;
    get byteIndex(): number;
    set byteIndex(val: number);
    get buffer(): ArrayBufferLike;
    get view(): BitView;
    get bigEndian(): boolean;
    set bigEndian(val: boolean);
    protected reader<T extends number | boolean, F extends (offset: number) => T = (offset: number) => T>(name: keyof BitView, size: number): () => T;
    protected writer<T extends number | boolean, F extends (offset: number, value: T) => void = (offset: number, value: T) => void>(name: keyof BitView, size: number): (value: T) => void;
    protected readString(bytes?: number, utf8?: boolean): string;
    readBits(bits: number, signed?: boolean): number;
    peakBits(offset: number, bits: number, signed?: boolean): number;
    writeBits(value: number, bits: number): void;
    readBoolean: () => boolean;
    readInt8: () => number;
    readUint8: () => number;
    readInt16: () => number;
    readUint16: () => number;
    readInt32: () => number;
    readUint32: () => number;
    readFloat32: () => number;
    readFloat64: () => number;
    writeBoolean: (value: boolean) => void;
    writeInt8: (value: number) => void;
    writeUint8: (value: number) => void;
    writeInt16: (value: number) => void;
    writeUint16: (value: number) => void;
    writeInt32: (value: number) => void;
    writeUint32: (value: number) => void;
    writeFloat32: (value: number) => void;
    writeFloat64: (value: number) => void;
    readASCIIString(bytes?: number): string;
    readUTF8String(bytes?: number): string;
    writeASCIIString(string: string, bytes?: number): void;
    writeUTF8String(string: string, bytes: number): void;
    readBitStream(bitLength: number): BitStream;
    writeBitStream(stream: BitStream, length: number): void;
    readArrayBuffer(byteLength: number): Uint8Array;
    writeArrayBuffer(buffer: ArrayBuffer, byteLength: number): void;
}
//# sourceMappingURL=bit-buffer.d.ts.map